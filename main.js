/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  MultLineHandle: () => MultLineHandle,
  default: () => BlockLinkPlus
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var MultLineHandle = /* @__PURE__ */ ((MultLineHandle2) => {
  MultLineHandle2[MultLineHandle2["oneline"] = 0] = "oneline";
  MultLineHandle2[MultLineHandle2["heading"] = 1] = "heading";
  MultLineHandle2[MultLineHandle2["multblock"] = 2] = "multblock";
  return MultLineHandle2;
})(MultLineHandle || {});
var DEFAULT_SETTINGS = {
  mult_line_handle: 0 /* oneline */,
  // as one line handle
  enble_prefix: false,
  // no prefix
  id_prefix: "",
  // prefix
  id_length: 4
  // id length
};
function generateRandomId(prefix, length) {
  if (length < 3 || length > 7) {
    throw new Error("Length must be between 3 and 7.");
  }
  const separator = prefix ? "-" : "";
  return `${prefix}${separator}${Math.random().toString(36).substring(2, 2 + length)}`;
}
function shouldInsertAfter(block) {
  if (block.type) {
    return [
      "blockquote",
      "code",
      "table",
      "comment",
      "footnoteDefinition"
    ].includes(block.type);
  }
}
function analyzeHeadings(fileCache, start_line, end_line) {
  var _a, _b;
  if (!fileCache || end_line < start_line) {
    return {
      isValid: false,
      start_line,
      end_line,
      isMultiline: false,
      block: null,
      nearestBeforeStartLevel: 0,
      minLevelInRange: Infinity,
      hasHeadingAtStart: false,
      hasHeadingAtEnd: false,
      headingAtStart: null,
      headingAtEnd: null,
      isStartHeadingMinLevel: false,
      isEndLineJustBeforeHeading: false
    };
  }
  if (start_line == end_line) {
    let head_block = (_a = fileCache.headings) == null ? void 0 : _a.find(
      (heading) => {
        const { start, end } = heading.position;
        return start.line == start_line;
      }
    );
    let block2 = (fileCache.sections || []).find((section) => {
      return section.position.start.line <= end_line && section.position.end.line >= end_line;
    });
    return {
      isValid: true,
      start_line,
      end_line,
      isMultiline: false,
      block: block2,
      nearestBeforeStartLevel: 0,
      minLevelInRange: head_block ? head_block.level : Infinity,
      hasHeadingAtStart: !!block2,
      hasHeadingAtEnd: false,
      headingAtStart: head_block || null,
      headingAtEnd: null,
      isStartHeadingMinLevel: block2 ? true : false,
      isEndLineJustBeforeHeading: false
    };
  }
  let nearestBeforeStartLevel = 0;
  let minLevelInRange = Infinity;
  let hasHeadingAtStart = false;
  let hasHeadingAtEnd = false;
  let headingAtStart = null;
  let headingAtEnd = null;
  let isStartHeadingMinLevel = false;
  let isEndLineJustBeforeHeading = false;
  let closestBeforeStartDistance = Infinity;
  let inner_levels = new Array();
  (_b = fileCache.headings) == null ? void 0 : _b.forEach((heading) => {
    const { start, end } = heading.position;
    if (start.line < start_line) {
      const distance = start_line - start.line;
      if (start_line - start.line < closestBeforeStartDistance) {
        closestBeforeStartDistance = distance;
        nearestBeforeStartLevel = heading.level;
      }
    }
    if (start.line >= start_line && end.line <= end_line) {
      minLevelInRange = Math.min(minLevelInRange, heading.level);
      inner_levels.push(heading.level);
    }
    if (start.line === start_line) {
      hasHeadingAtStart = true;
      headingAtStart = heading;
    }
    if (start.line === end_line) {
      hasHeadingAtEnd = true;
      headingAtEnd = heading;
    }
    if (start.line === end_line + 1 || start.line === end_line + 2) {
      isEndLineJustBeforeHeading = true;
    }
  });
  if (hasHeadingAtStart && headingAtStart != null) {
    if (headingAtStart.level === minLevelInRange) {
      const minLevel = Math.min(...inner_levels);
      const countOfMinLevel = inner_levels.filter(
        (level) => level === minLevel
      ).length;
      if (headingAtStart && // @ts-ignore
      headingAtStart.level === minLevel && countOfMinLevel === 1) {
        isStartHeadingMinLevel = true;
      }
    }
  }
  let block = (fileCache.sections || []).find((section) => {
    return section.position.start.line <= end_line && section.position.end.line >= end_line;
  });
  return {
    isValid: true,
    start_line,
    end_line,
    isMultiline: true,
    block,
    nearestBeforeStartLevel,
    minLevelInRange,
    hasHeadingAtStart,
    hasHeadingAtEnd,
    headingAtStart,
    headingAtEnd,
    isStartHeadingMinLevel,
    isEndLineJustBeforeHeading
  };
}
function get_is_heading(head_analysis) {
  if (!head_analysis.isValid) {
    return false;
  }
  if (!head_analysis.isMultiline) {
    if (head_analysis.hasHeadingAtStart && head_analysis.headingAtStart != null)
      return true;
  } else {
    if (head_analysis.hasHeadingAtStart && // start_line is a heading
    head_analysis.isStartHeadingMinLevel)
      return true;
  }
  return false;
}
function gen_insert_blocklink_singleline(block, editor, settings) {
  if (block.id) {
    return `^${block.id}`;
  }
  const sectionEnd = block.position.end;
  const end = {
    ch: sectionEnd.col,
    line: sectionEnd.line
  };
  const id = generateRandomId(
    settings.enble_prefix ? settings.id_prefix : "",
    settings.id_length
  );
  const spacer = shouldInsertAfter(block) ? "\n\n" : " ";
  editor.replaceRange(`${spacer}^${id}`, end);
  return `^${id}`;
}
function gen_insert_blocklink_multline_heading(block, editor, settings, heading_level) {
  const id = generateRandomId(
    settings.enble_prefix ? settings.id_prefix : "",
    settings.id_length
  );
  const sectionEnd = block.position.end;
  const end = {
    ch: sectionEnd.col,
    line: sectionEnd.line
  };
  const heading = "#".repeat(heading_level);
  editor.replaceRange(`

 ${heading} ^${id}`, end);
  const cursor = editor.getCursor("from");
  editor.setCursor(cursor.line, cursor.ch);
  editor.replaceRange(`${heading} \u02C5${id}

`, {
    line: cursor.line,
    ch: 0
  });
  return `\u02C5${id}`;
}
function gen_insert_blocklink_multline_block(fileCache, editor, settings) {
  if (fileCache.sections == null)
    return "";
  const start_line = editor.getCursor("from").line;
  const end_line = editor.getCursor("to").line;
  const sortedSections = [...fileCache.sections].sort(
    (a, b) => a.position.start.line - b.position.start.line
  );
  let links = new Array();
  for (const section of sortedSections) {
    if (section.position.start.line > end_line)
      break;
    if (section.position.start.line >= start_line && section.position.end.line <= end_line) {
      const id = gen_insert_blocklink_singleline(
        section,
        editor,
        settings
      );
      links.push(id);
    }
  }
  return links;
}
function markdownPostProcessor(el) {
  if (el.firstChild instanceof Node) {
    let walker = document.createTreeWalker(
      el.firstChild,
      NodeFilter.SHOW_TEXT,
      null
    );
    let nodes = [];
    let node;
    while (node = walker.nextNode()) {
      nodes.push(node);
    }
    for (node of nodes) {
      node.textContent = node.textContent.replace(
        /\s*˅[a-zA-Z0-9-]*/g,
        ""
      );
    }
  }
}
function createViewPlugin(rule = "(^| )\u02C5[a-zA-Z0-9_]+$") {
  let decorator = new import_view.MatchDecorator({
    regexp: new RegExp(rule, "g"),
    decoration: import_view.Decoration.mark({ class: "small-font" })
  });
  return import_view.ViewPlugin.define(
    (view) => ({
      decorations: decorator.createDeco(view),
      update(u) {
        this.decorations = decorator.updateDeco(u, this.decorations);
      }
    }),
    {
      decorations: (v) => v.decorations
    }
  );
}
var BlockLinkPlus = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.appName = this.manifest.name;
    this.editorExtensions = [];
  }
  async onload() {
    console.log(`loading ${this.appName}`);
    await this.loadSettings();
    this.addSettingTab(new BlockLinkPlusSettingsTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on(
        "editor-menu",
        this.handleEditorMenu.bind(this)
      )
    );
    this.addCommand({
      id: "copy-link-to-block2",
      name: "Copy link to current block or heading",
      editorCheckCallback: (isChecking, editor, view) => {
        return this.handleCommand(isChecking, editor, view, false);
      }
    });
    this.addCommand({
      id: "copy-embed-to-block2",
      name: "Copy embed to current block or heading",
      editorCheckCallback: (isChecking, editor, view) => {
        return this.handleCommand(isChecking, editor, view, true);
      }
    });
    this.registerMarkdownPostProcessor(markdownPostProcessor);
    this.viewPlugin = createViewPlugin();
    this.registerEditorExtension([this.viewPlugin]);
  }
  // Creates new LinkifyViewPlugins and registers them.
  // refreshExtensions() {
  // 	this.viewPlugin = createViewPlugin();
  // 	this.app.workspace.updateOptions();
  // }
  handleEditorMenu(menu, editor, view) {
    const file = view.file;
    if (!file)
      return;
    const start_line = editor.getCursor("from").line;
    const end_line = editor.getCursor("to").line;
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!fileCache)
      return;
    let head_analysis = analyzeHeadings(fileCache, start_line, end_line);
    if (!head_analysis.isValid) {
      return;
    }
    let isHeading = get_is_heading(head_analysis);
    const addItemToMenu = (title, isEmbed) => {
      menu.addItem((item) => {
        item.setTitle(title).setIcon("links-coming-in").onClick(
          () => this.handleMenuItemClick(
            view,
            isHeading,
            isEmbed,
            head_analysis
          )
        );
      });
    };
    addItemToMenu(
      isHeading ? "Copy link to heading" : "Copy link to block",
      false
    );
    addItemToMenu(
      isHeading ? "Copy heading embed" : "Copy block embed",
      true
    );
  }
  handleMenuItemClick(view, isHeading, isEmbed, head_analysis) {
    if (!view.file || !head_analysis.isValid)
      return;
    const { file, editor } = view;
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!fileCache)
      return;
    if (!head_analysis.isMultiline) {
      this.handleSingleLine(
        file,
        isHeading,
        isEmbed,
        head_analysis,
        editor
      );
    } else {
      this.handleMultiLine(
        file,
        isHeading,
        isEmbed,
        head_analysis,
        editor,
        fileCache
      );
    }
  }
  handleSingleLine(file, isHeading, isEmbed, head_analysis, editor) {
    if (isHeading && head_analysis.headingAtStart) {
      this.copyToClipboard(
        file,
        head_analysis.headingAtStart.heading,
        isEmbed
      );
    } else if (!isHeading && head_analysis.block) {
      const link = gen_insert_blocklink_singleline(
        head_analysis.block,
        editor,
        this.settings
      );
      this.copyToClipboard(file, link, isEmbed);
    }
  }
  handleMultiLine(file, isHeading, isEmbed, head_analysis, editor, fileCache) {
    if (isHeading && head_analysis.headingAtStart) {
      this.copyToClipboard(
        file,
        head_analysis.headingAtStart.heading,
        isEmbed
      );
    } else {
      this.handleMultiLineBlock(
        file,
        isEmbed,
        head_analysis,
        editor,
        fileCache
      );
    }
  }
  _gen_insert_blocklink_multline_heading(fileCache, editor, head_analysis) {
    if (!head_analysis.block)
      return "";
    return gen_insert_blocklink_multline_heading(
      head_analysis.block,
      editor,
      this.settings,
      head_analysis.nearestBeforeStartLevel + 1
    );
  }
  _gen_insert_blocklink_multline_block(fileCache, editor, head_analysis) {
    return gen_insert_blocklink_multline_block(
      fileCache,
      editor,
      this.settings
    );
  }
  handleMultiLineBlock(file, isEmbed, head_analysis, editor, fileCache) {
    if (this.settings.mult_line_handle == 0 /* oneline */) {
      if (head_analysis.block) {
        const link = gen_insert_blocklink_singleline(
          head_analysis.block,
          editor,
          this.settings
        );
        this.copyToClipboard(file, link, isEmbed);
      }
      return;
    } else {
      if (head_analysis.minLevelInRange != Infinity) {
        new import_obsidian.Notice(
          `Please select text that does not include headings`,
          1500
        );
        return;
      }
      const linkMethod = this.settings.mult_line_handle == 1 /* heading */ ? this._gen_insert_blocklink_multline_heading : this._gen_insert_blocklink_multline_block;
      const link = linkMethod.call(
        this,
        fileCache,
        editor,
        head_analysis
      );
      this.copyToClipboard(file, link, isEmbed);
      return;
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  handleCommand(isChecking, editor, view, isEmbed) {
    if (isChecking) {
      return true;
    }
    const file = view.file;
    if (!file)
      return;
    const start_line = editor.getCursor("from").line;
    const end_line = editor.getCursor("to").line;
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!fileCache)
      return;
    let head_analysis = analyzeHeadings(fileCache, start_line, end_line);
    if (!head_analysis.isValid) {
      return;
    }
    let isHeading = get_is_heading(head_analysis);
    if (!head_analysis.isMultiline) {
      this.handleSingleLine(
        file,
        isHeading,
        isEmbed,
        head_analysis,
        editor
      );
    } else {
      this.handleMultiLine(
        file,
        isHeading,
        isEmbed,
        head_analysis,
        editor,
        fileCache
      );
    }
    return true;
  }
  /**
   * Copies links to one or more blocks to the clipboard.
   *
   * @param file - The file containing the blocks.
   * @param links - An array of block links (^id) or heading links (heading without `#`).
   * @param isEmbed - Specifies whether the links should be embedded.
   * @param alias - An optional alias for the links.
   */
  copyToClipboard(file, links, isEmbed, alias) {
    const linksArray = typeof links === "string" ? [links] : links;
    const markdownLinks = linksArray.map((link, index) => {
      const addNewLine = index < links.length - 1 ? "\n" : "";
      return `${isEmbed ? "!" : ""}${this.app.fileManager.generateMarkdownLink(
        file,
        "",
        "#" + link,
        alias
      )}${addNewLine}`;
    }).join("");
    navigator.clipboard.writeText(markdownLinks);
  }
};
var BlockLinkPlusSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  addToggleSetting(settingName, extraOnChange) {
    return new import_obsidian.Setting(this.containerEl).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings[settingName]).onChange(async (value) => {
        this.plugin.settings[settingName] = value;
        await this.plugin.saveSettings();
        extraOnChange == null ? void 0 : extraOnChange(value);
      });
    });
  }
  // 文本输入框
  addTextInputSetting(settingName, placeholder) {
    return new import_obsidian.Setting(this.containerEl).addText(
      (text) => text.setPlaceholder(placeholder).setValue(this.plugin.settings[settingName]).onChange(async (value) => {
        if (value.length > 0) {
          this.plugin.settings[settingName] = value;
          await this.plugin.saveSettings();
        }
      })
    );
  }
  addDropdownSetting(settingName, options, display) {
    return new import_obsidian.Setting(this.containerEl).addDropdown((dropdown) => {
      var _a;
      const displayNames = /* @__PURE__ */ new Set();
      for (const option of options) {
        const displayName = (_a = display == null ? void 0 : display(option)) != null ? _a : option;
        if (!displayNames.has(displayName)) {
          dropdown.addOption(option, displayName);
          displayNames.add(displayName);
        }
      }
      dropdown.setValue(this.plugin.settings[settingName]).onChange(async (value) => {
        this.plugin.settings[settingName] = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addSliderSetting(settingName, min, max, step) {
    return new import_obsidian.Setting(this.containerEl).addSlider((slider) => {
      slider.setLimits(min, max, step).setValue(this.plugin.settings[settingName]).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings[settingName] = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addHeading(heading) {
    return new import_obsidian.Setting(this.containerEl).setName(heading).setHeading();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Block-link Settings" });
    this.addDropdownSetting(
      //@ts-ignore
      "mult_line_handle",
      ["0", "1", "2"],
      (option) => {
        const optionsSet = /* @__PURE__ */ new Map([
          ["0", "Default"],
          ["1", "Add new heading"],
          ["2", "Add multi block"]
        ]);
        return optionsSet.get(option) || "Unknown";
      }
    ).setName("Multi-line Block Behavior").setDesc(
      "Define how multi-line selections generate block IDs. 'Default' treats them as a single line."
    );
    this.addHeading("Block ID settings");
    this.addSliderSetting("id_length", 3, 7, 1).setName("Max Block ID Length").setDesc("Set the maximum number of characters for a block ID.");
    this.addToggleSetting("enble_prefix").setName("Custom ID Prefix");
    this.addTextInputSetting("id_prefix", "").setName("Block ID Prefix").setDesc("Block ID will be: prefix-random_str");
  }
};
